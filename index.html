<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Reaction: Kinetic Edition</title>
    <style>
        :root {
            --bg: #050505;
            --glass: rgba(20, 20, 30, 0.7);
            --border: rgba(255, 255, 255, 0.1);
            --accent: #00f3ff;
            --accent-glow: rgba(0, 243, 255, 0.4);
            --danger: #ff0055;
            --gold: #ffd700;
            --text-dim: #8899a6;
            --panel-height: 160px; /* Defined here for CSS */
        }

        body {
            margin: 0;
            overflow: hidden;
            background-color: var(--bg);
            font-family: 'Segoe UI', Roboto, Helvetica, Arial, sans-serif;
            color: #ffffff;
            user-select: none;
            -webkit-user-select: none;
            touch-action: none;
        }

        /* --- BACKGROUND GRID --- */
        #grid {
            position: absolute;
            width: 200%;
            height: 200%;
            background-image: 
                linear-gradient(var(--border) 1px, transparent 1px),
                linear-gradient(90deg, var(--border) 1px, transparent 1px);
            background-size: 50px 50px;
            opacity: 0.15;
            transform: perspective(500px) rotateX(60deg) translateY(-100px) translateZ(-200px);
            animation: gridMove 20s linear infinite;
            pointer-events: none;
            z-index: 0;
        }

        @keyframes gridMove {
            0% { transform: perspective(500px) rotateX(60deg) translateY(0) translateZ(-200px); }
            100% { transform: perspective(500px) rotateX(60deg) translateY(50px) translateZ(-200px); }
        }

        /* --- HUD --- */
        #hud {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            padding: 20px;
            box-sizing: border-box;
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
            pointer-events: none;
            z-index: 10;
        }

        .hud-panel {
            background: var(--glass);
            backdrop-filter: blur(10px);
            -webkit-backdrop-filter: blur(10px);
            border: 1px solid var(--border);
            padding: 10px 20px;
            border-radius: 12px;
            box-shadow: 0 4px 30px rgba(0, 0, 0, 0.5);
        }

        .currency-label { font-size: 12px; text-transform: uppercase; letter-spacing: 2px; color: var(--text-dim); margin-bottom: 4px; }
        #credits { font-size: 28px; font-weight: 800; color: var(--accent); text-shadow: 0 0 15px var(--accent-glow); font-variant-numeric: tabular-nums; }

        /* --- COMBO DISPLAY --- */
        #combo-container {
            position: absolute;
            top: 30%; /* Moved down slightly */
            left: 50%;
            transform: translate(-50%, -50%);
            text-align: center;
            pointer-events: none;
            z-index: 5;
            opacity: 0;
            transition: opacity 0.2s, transform 0.1s cubic-bezier(0.175, 0.885, 0.32, 1.275);
        }

        #combo-val { font-size: 60px; font-weight: 900; color: var(--danger); text-shadow: 0 0 20px rgba(255, 0, 85, 0.6); line-height: 1; }
        #combo-text { font-size: 14px; letter-spacing: 6px; text-transform: uppercase; font-weight: bold; color: #fff; }

        /* --- SHOP / BOTTOM PANEL --- */
        #control-deck {
            position: absolute;
            bottom: 0;
            left: 0;
            width: 100%;
            height: var(--panel-height);
            background: rgba(10, 10, 15, 0.9);
            backdrop-filter: blur(20px);
            -webkit-backdrop-filter: blur(20px);
            border-top: 1px solid var(--border);
            display: flex;
            align-items: center;
            padding: 0 15px;
            gap: 15px;
            overflow-x: auto;
            z-index: 20;
            box-sizing: border-box;
            box-shadow: 0 -10px 40px rgba(0,0,0,0.8);
        }
        
        #control-deck::-webkit-scrollbar { display: none; }

        #inject-btn {
            width: 110px;
            height: 110px;
            background: linear-gradient(135deg, #1a1a2e, #16213e);
            border: 2px solid var(--accent);
            border-radius: 16px;
            color: var(--accent);
            flex-shrink: 0;
            cursor: pointer;
            position: relative;
            overflow: hidden;
            transition: transform 0.1s;
            box-shadow: 0 0 15px var(--accent-glow);
        }
        #inject-btn:active { transform: scale(0.95); }
        #inject-btn.cooldown { border-color: #333; color: #555; box-shadow: none; pointer-events: none; }

        #inject-fill {
            position: absolute;
            bottom: 0;
            left: 0;
            width: 100%;
            height: 0%;
            background: var(--accent);
            opacity: 0.2;
            transition: height 0.1s linear;
        }

        .btn-label { position: relative; z-index: 2; font-weight: 800; font-size: 14px; text-transform: uppercase; letter-spacing: 1px; }
        .btn-sub { font-size: 10px; color: var(--text-dim); margin-top: 4px; }

        .card {
            width: 100px;
            height: 110px;
            background: rgba(255, 255, 255, 0.03);
            border: 1px solid var(--border);
            border-radius: 12px;
            flex-shrink: 0;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
            padding: 10px;
            box-sizing: border-box;
            cursor: pointer;
            transition: background 0.2s;
        }
        .card:hover { background: rgba(255, 255, 255, 0.08); }
        .card:active { transform: translateY(2px); }
        .card.disabled { opacity: 0.4; pointer-events: none; border-color: transparent; }

        .c-title { font-size: 10px; color: var(--text-dim); text-transform: uppercase; font-weight: 700; }
        .c-val { font-size: 16px; color: #fff; font-weight: 600; text-align: center; margin: auto 0; }
        .c-cost { font-size: 11px; color: var(--gold); text-align: right; font-weight: 600; }

        canvas { display: block; position: relative; z-index: 1; }
        
    </style>
</head>
<body>

    <div id="grid"></div>

    <div id="hud">
        <div class="hud-panel">
            <div class="currency-label">Credits</div>
            <div id="credits">0</div>
        </div>
        <div class="hud-panel" style="text-align: right;">
            <div class="currency-label">Entities</div>
            <div style="font-weight: bold;"><span id="pop-count">0</span> / <span id="pop-cap">30</span></div>
        </div>
    </div>

    <div id="combo-container">
        <div id="combo-val">x1.0</div>
        <div id="combo-text">KINETIC CHAIN</div>
    </div>

    <div id="control-deck">
        <button id="inject-btn" onclick="triggerInject()">
            <div id="inject-fill"></div>
            <div class="btn-label">INJECT</div>
            <div class="btn-sub">BATCH SPAWN</div>
        </button>

        <div class="card" id="card-batch" onclick="buyUpgrade('batch')">
            <div class="c-title">Batch Size</div>
            <div class="c-val" id="val-batch">5</div>
            <div class="c-cost" id="cost-batch">400</div>
        </div>
        <div class="card" id="card-shrapnel" onclick="buyUpgrade('shrapnel')">
            <div class="c-title">Explosives</div>
            <div class="c-val" id="val-shrapnel">3</div>
            <div class="c-cost" id="cost-shrapnel">50</div>
        </div>
        <div class="card" id="card-luck" onclick="buyUpgrade('luck')">
            <div class="c-title">Luck</div>
            <div class="c-val" id="val-luck">1%</div>
            <div class="c-cost" id="cost-luck">500</div>
        </div>
        <div class="card" id="card-cap" onclick="buyUpgrade('cap')">
            <div class="c-title">Capacity</div>
            <div class="c-val" id="val-cap">30</div>
            <div class="c-cost" id="cost-cap">150</div>
        </div>
        <div class="card" id="card-auto" onclick="buyUpgrade('auto')">
            <div class="c-title">Auto Rate</div>
            <div class="c-val" id="val-auto">2.0s</div>
            <div class="c-cost" id="cost-auto">300</div>
        </div>
    </div>

    <canvas id="gameCanvas"></canvas>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d', { alpha: false });
        
        let width, height;
        // The safe zone definition
        const PANEL_HEIGHT = 160;

        // --- GAME LOGIC STATE ---
        let credits = 0;
        let circles = [];
        let particles = [];
        let texts = [];
        
        // Timers
        let lastAutoSpawn = 0;
        
        // Cooldown
        let injectCooldown = 0;
        const INJECT_COOLDOWN_MAX = 60;

        // Combo
        let combo = 0;
        let comboMultiplier = 1.0;
        let comboTimer = 0;
        const COMBO_DECAY = 80;

        // Upgrades
        const upgrades = {
            batch:    { val: 5,    cost: 400, mult: 1.0, fmt: (v) => v },
            shrapnel: { val: 4,    cost: 50,  mult: 1.0, fmt: (v) => v.toFixed(0) },
            luck:     { val: 1,    cost: 500, mult: 1.0, fmt: (v) => v + "%" },
            cap:      { val: 30,   cost: 150, mult: 1.0, fmt: (v) => v },
            auto:     { val: 2000, cost: 300, mult: 1.0, fmt: (v) => (v/1000).toFixed(1) + 's' }
        };

        // --- CLASSES ---

        class FloatingText {
            constructor(x, y, text, color, size) {
                this.x = x;
                this.y = y;
                this.text = text;
                this.color = color;
                this.size = size;
                this.life = 1.0;
                this.dy = -2;
            }
            update() {
                this.y += this.dy;
                this.life -= 0.02;
            }
            draw() {
                ctx.globalAlpha = Math.max(0, this.life);
                ctx.font = `bold ${this.size}px Arial`;
                ctx.fillStyle = this.color;
                ctx.fillText(this.text, this.x, this.y);
                ctx.globalAlpha = 1;
            }
        }

        class Circle {
            constructor(x, y, isGolden = false) {
                this.x = x;
                this.y = y;
                this.radius = isGolden ? 14 : Math.random() * 12 + 10;
                this.mass = this.radius; // Physics mass approximation
                this.isGolden = isGolden;
                
                const speedMult = isGolden ? 2.5 : 1.0;
                this.vx = (Math.random() - 0.5) * 4 * speedMult;
                this.vy = (Math.random() - 0.5) * 4 * speedMult;
                
                this.color = isGolden ? '#ffd700' : `hsl(${Math.random() * 50 + 170}, 80%, 60%)`;
                this.markedForDeletion = false;
                this.spawnAnim = 0;
            }

            update() {
                if(this.spawnAnim < 1) this.spawnAnim += 0.1;
                
                // --- WALL BOUNCING ---
                // X Axis
                if (this.x + this.radius > width) {
                    this.x = width - this.radius;
                    this.vx *= -1;
                } else if (this.x - this.radius < 0) {
                    this.x = this.radius;
                    this.vx *= -1;
                }

                // Y Axis - CRITICAL FIX: Use (height - PANEL_HEIGHT) as the floor
                const floor = height - PANEL_HEIGHT;
                
                if (this.y + this.radius > floor) {
                    this.y = floor - this.radius;
                    this.vy *= -1;
                } else if (this.y - this.radius < 0) {
                    this.y = this.radius;
                    this.vy *= -1;
                }

                this.x += this.vx;
                this.y += this.vy;
            }

            draw() {
                ctx.beginPath();
                const r = this.radius * this.spawnAnim;
                ctx.arc(this.x, this.y, r, 0, Math.PI * 2);
                
                if (this.isGolden) {
                    ctx.fillStyle = '#ffd700';
                    ctx.shadowBlur = 15;
                    ctx.shadowColor = '#ffd700';
                } else {
                    ctx.fillStyle = this.color;
                    ctx.shadowBlur = 0;
                }
                
                ctx.fill();
                ctx.strokeStyle = 'rgba(255,255,255,0.4)';
                ctx.lineWidth = 2;
                ctx.stroke();
                ctx.shadowBlur = 0;
                ctx.closePath();
            }
        }

        class Particle {
            constructor(x, y, isGolden) {
                this.x = x;
                this.y = y;
                const angle = Math.random() * Math.PI * 2;
                const speed = isGolden ? 12 : 7; 
                this.vx = Math.cos(angle) * speed;
                this.vy = Math.sin(angle) * speed;
                this.life = 60;
                this.isGolden = isGolden;
                this.markedForDeletion = false;
            }

            update() {
                this.x += this.vx;
                this.y += this.vy;
                this.life--;

                if (this.x < 0) this.x = width;
                if (this.x > width) this.x = 0;
                if (this.y < 0) this.y = height - PANEL_HEIGHT; // Particles also respect floor
                if (this.y > height - PANEL_HEIGHT) this.y = 0;

                if (this.life <= 0) this.markedForDeletion = true;
            }

            draw() {
                ctx.globalAlpha = this.life / 60;
                ctx.fillStyle = this.isGolden ? '#fff' : '#00f3ff';
                ctx.beginPath();
                ctx.arc(this.x, this.y, 3, 0, Math.PI * 2);
                ctx.fill();
                ctx.globalAlpha = 1;
            }
        }

        // --- PHYSICS ENGINE ---

        // Elastic Collision Resolution
        function resolveCollision(p1, p2) {
            const dx = p1.x - p2.x;
            const dy = p1.y - p2.y;
            const distance = Math.hypot(dx, dy);

            if (distance < p1.radius + p2.radius) {
                // 1. Resolve Overlap (prevent sticking)
                const overlap = (p1.radius + p2.radius - distance) / 2;
                const nx = dx / distance;
                const ny = dy / distance;
                
                p1.x += nx * overlap;
                p1.y += ny * overlap;
                p2.x -= nx * overlap;
                p2.y -= ny * overlap;

                // 2. Resolve Velocity (Elastic Bounce)
                const normalX = nx;
                const normalY = ny;
                const tangentX = -normalY;
                const tangentY = normalX;

                // Dot Product Tangent
                const dpTan1 = p1.vx * tangentX + p1.vy * tangentY;
                const dpTan2 = p2.vx * tangentX + p2.vy * tangentY;

                // Dot Product Normal
                const dpNorm1 = p1.vx * normalX + p1.vy * normalY;
                const dpNorm2 = p2.vx * normalX + p2.vy * normalY;

                // Conservation of Momentum (1D collision along normal)
                const m1 = p1.mass;
                const m2 = p2.mass;

                const m1_new = (dpNorm1 * (m1 - m2) + 2 * m2 * dpNorm2) / (m1 + m2);
                const m2_new = (dpNorm2 * (m2 - m1) + 2 * m1 * dpNorm1) / (m1 + m2);

                // Update Velocities
                p1.vx = tangentX * dpTan1 + normalX * m1_new;
                p1.vy = tangentY * dpTan1 + normalY * m1_new;
                p2.vx = tangentX * dpTan2 + normalX * m2_new;
                p2.vy = tangentY * dpTan2 + normalY * m2_new;
            }
        }

        // --- CORE FUNCTIONS ---

        function init() {
            resize();
            window.addEventListener('resize', resize);
            canvas.addEventListener('pointerdown', handleInput);
            updateUI();
            requestAnimationFrame(loop);
        }

        function resize() {
            width = canvas.width = window.innerWidth;
            height = canvas.height = window.innerHeight;
        }

        function spawnCircle(forceGolden = false) {
            if (circles.length >= upgrades.cap.val) return;
            
            // Spawn only in the Safe Zone
            const r = 15;
            const x = Math.random() * (width - 2*r) + r;
            const safeHeight = height - PANEL_HEIGHT - 20; // Safe floor
            const y = Math.random() * (safeHeight - 100) + 50; 
            
            const isGolden = forceGolden || (Math.random() * 100 < upgrades.luck.val);
            circles.push(new Circle(x, y, isGolden));
        }

        function triggerInject() {
            if(injectCooldown > 0) return;
            let count = 0;
            while(circles.length < upgrades.cap.val && count < upgrades.batch.val) {
                spawnCircle();
                count++;
            }
            injectCooldown = INJECT_COOLDOWN_MAX;
            updateInjectBtn();
        }

        function explode(circle) {
            circle.markedForDeletion = true;
            combo++;
            comboTimer = COMBO_DECAY;
            comboMultiplier = 1 + (Math.log1p(combo) * 0.5);
            
            let baseScore = circle.isGolden ? 250 : 10;
            let finalScore = Math.floor(baseScore * comboMultiplier);
            credits += finalScore;

            const color = circle.isGolden ? '#ffd700' : '#fff';
            const size = circle.isGolden ? 30 : (16 + Math.min(10, combo/2));
            texts.push(new FloatingText(circle.x, circle.y, `+${finalScore}`, color, size));

            const count = Math.floor(upgrades.shrapnel.val) + (circle.isGolden ? 10 : 0);
            for(let i=0; i<count; i++) {
                particles.push(new Particle(circle.x, circle.y, circle.isGolden));
            }
            
            updateUI();
            updateComboVisuals();
        }

        function handleInput(e) {
            // No need to check Y-coordinate protection because circles physically can't go there anymore!
            const rect = canvas.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;

            circles.forEach(c => {
                const dist = Math.hypot(x - c.x, y - c.y);
                if(dist < c.radius + 15) {
                    explode(c);
                }
            });
        }

        function buyUpgrade(key) {
            const up = upgrades[key];
            if (credits >= up.cost) {
                credits -= up.cost;
                if (key === 'batch') up.val++;
                if (key === 'shrapnel') up.val++;
                if (key === 'luck') up.val++;
                if (key === 'cap') up.val += 5;
                if (key === 'auto') up.val = Math.max(200, up.val * 0.9);
                up.cost = Math.floor(up.cost * up.mult);
                updateUI();
            }
        }

        function updateUI() {
            document.getElementById('credits').innerText = credits.toLocaleString();
            document.getElementById('pop-count').innerText = circles.length;
            document.getElementById('pop-cap').innerText = upgrades.cap.val;
            
            for (const [key, up] of Object.entries(upgrades)) {
                document.getElementById(`val-${key}`).innerText = up.fmt(up.val);
                document.getElementById(`cost-${key}`).innerText = up.cost.toLocaleString();
                const card = document.getElementById(`card-${key}`);
                if (credits < up.cost) card.classList.add('disabled');
                else card.classList.remove('disabled');
            }
        }

        function updateInjectBtn() {
            const btn = document.getElementById('inject-btn');
            const fill = document.getElementById('inject-fill');
            if (injectCooldown > 0) {
                btn.classList.add('cooldown');
                const pct = 100 - ((injectCooldown / INJECT_COOLDOWN_MAX) * 100);
                fill.style.height = `${pct}%`;
            } else {
                btn.classList.remove('cooldown');
                fill.style.height = '0%';
            }
        }

        function updateComboVisuals() {
            const container = document.getElementById('combo-container');
            const val = document.getElementById('combo-val');
            if (combo > 1) {
                container.style.opacity = 1;
                let scale = Math.min(1.3, 1 + (combo / 40)); 
                container.style.transform = `translate(-50%, -50%) scale(${scale})`;
                val.innerText = `x${comboMultiplier.toFixed(1)}`;
            } else {
                container.style.opacity = 0;
                container.style.transform = `translate(-50%, -50%) scale(0.8)`;
            }
        }

        function loop(timestamp) {
            ctx.fillStyle = '#050505';
            ctx.fillRect(0, 0, width, height);

            if (injectCooldown > 0) {
                injectCooldown--;
                updateInjectBtn();
            }

            if (combo > 0) {
                comboTimer--;
                if (comboTimer <= 0) {
                    combo = 0;
                    comboMultiplier = 1;
                    updateComboVisuals();
                }
            }

            if (timestamp - lastAutoSpawn > upgrades.auto.val) {
                spawnCircle();
                lastAutoSpawn = timestamp;
                updateUI();
            }

            // --- COLLISIONS & PHYSICS STEPS ---
            
            // 1. Move Circles
            circles = circles.filter(c => !c.markedForDeletion);
            circles.forEach(c => c.update());

            // 2. Resolve Collisions (N^2 check, fine for <100 objects)
            for (let i = 0; i < circles.length; i++) {
                for (let j = i + 1; j < circles.length; j++) {
                    resolveCollision(circles[i], circles[j]);
                }
            }

            // 3. Draw Circles
            circles.forEach(c => c.draw());

            particles = particles.filter(p => !p.markedForDeletion);
            particles.forEach(p => {
                p.update();
                p.draw();
                // Particle-Circle Collision
                for (let c of circles) {
                    if (!c.markedForDeletion) {
                        const dx = p.x - c.x;
                        const dy = p.y - c.y;
                        if (Math.hypot(dx, dy) < c.radius + 5) {
                            p.markedForDeletion = true;
                            explode(c);
                            break; 
                        }
                    }
                }
            });

            texts = texts.filter(t => t.life > 0);
            texts.forEach(t => { t.update(); t.draw(); });

            requestAnimationFrame(loop);
        }

        init();

    </script>
</body>
</html>
